import lattice_symmetries as ls
import numpy as np
import operator
import scipy.sparse.linalg
import scipy.linalg as linalg
import igraph as ig
#import matplotlib.pyplot as plt

def thermal_average(observable, H, T):
    exp_H=linalg.expm(-H/T) #calculate matrix exponent
    density_matrix=exp_H/np.trace(exp_H)
    return np.trace(observable@density_matrix)

def square_distance(r, L): #here we assume that L is odd
    if r>L/2:
        return r-L
    else:
        return r
    
def structure_factor_nosym(qx,qy,cor_array, coords, L, N_sites): #calculate structure factor without symmetries for specific values of q
    sf=0
    for i in range(N_sites):
        rx=square_distance(coords[i][0],L)
        ry=square_distance(coords[i][1],L)
        sf += np.exp(1j*(qx*rx+qy*ry))*cor_array[i]/N_sites #here we use that the coordinates of the site with index 0 are (0,0)
        #print(i, rx,ry, np.exp(1j*(qx*coords[i][0]+qy*coords[i][1])), sf)
        #print(coords[i][0],coords[i][1])
    return np.real(sf)

def structure_factor_sym(qx,qy,sym_cor_array,coords, orbit_array, L,N_sites):
#calculate structure factor using symmetries for specific values of q
    sf=0
    for orb_ind in range(len(orbit_array)):
        for i in orbit_array[orb_ind]:
            rx=square_distance(coords[i][0],L)
            ry=square_distance(coords[i][1],L)
            sf += np.exp(1j*(qx*rx+qy*ry))*sym_cor_array[orb_ind]/N_sites #here we also use that the coordinates of the site with index 0 are (0,0)
        #print(i, rx,ry, np.exp(1j*(qx*coords[i][0]+qy*coords[i][1])), sf)
        #print(coords[i][0],coords[i][1])
    return np.real(sf)


def main():
    
    T=1 #temperature
    Nq=60 #discretization of q-space
    qxs = np.linspace(-3, 3, Nq)
    qys = np.linspace(-3, 3, Nq)
    L=3

    #define hamiltonian
    basic_expr = ls.Expr("Sx0 Sx1 + Sy0 Sy1 + Sz0 Sz1") # this basic expression is the building block of our Hamiltonian and correlation operators
    lattice=ig.Graph.Lattice(dim=[L, L])
    H_expr=basic_expr.on(lattice) # Hamiltonian expression, on square 3x3
    N_sites=H_expr.number_sites
    #For calculations we will also need coordinates of the vertices. Let's use ig.layout
    coords=lattice.layout_grid()

    #At first let's calculate structure factor without using any symmetry.
    #For that, we need to calculate correlations functions.
    full_basis=H_expr.full_basis()
    full_basis.build()
    H_op=ls.Operator(H_expr,full_basis)
    H_matrix=H_op.to_dense()#Make numpy matrix for matrix exponentiation
    cor_array=[]
    for i in range(N_sites):
        cor_expr=basic_expr.replace_indices({1: i}) #make operator S_0S_i
        cor_op=ls.Operator(cor_expr,full_basis)
        cor_matrix=cor_op.to_dense() #make numpy matrix
        cor_array.append(thermal_average(cor_matrix,H_matrix,T)) #calculate observable and add to array
    print("corrs", cor_array)

    SF=np.zeros((Nq,Nq))
    for i in range(Nq):
        for j in range(Nq):
            SF[i,j]=structure_factor_nosym(qxs[i],qys[j],cor_array,coords, L,N_sites)
    #print(SF)
    np.save("nosym_cors.npy", SF)
    
    #plot structure factor
    #h = plt.contourf(x, y, zs)
    #plt.axis('scaled')
    #plt.colorbar()
    #plt.savefig("structure_factor_no_symmetries.png")
    #plt.close()

    #Now, let's exploit the power of symmetries! 
    #We will divide our space on symmetric sectors, and use the fact that structure factor will be the same for some of the sectors.
    #In particular, we are interested in the symmetries generated by the point group.
    #Let's find it. We are looking for the subgroup, which fixes index 0.
    
    symmetries=H_expr.permutation_group()
    point_group=[]
    for symmetry in symmetries:
        list_form=symmetry.list()
        if list_form[0]==0:
            point_group.append(symmetry)
    #print("point group", point_group)
    #The next step is to find orbits of non-zero indices. 
    #If two indices can be transformed to each other by an element of a point group, they correspond to the same correlation function C_{0,i}.
    index_array=[i for i in range(1,N_sites)]
    #print("index array", index_array)
    orbit_array=[[0]] #zero index is always here and unique
    while index_array!=[]:
        index=index_array[0]
        index_array.remove(index)
        orbit=[index]
        #print("orbit", orbit)
        for symmetry in point_group:
            list_form=symmetry.list()
            new_index=list_form[index]
            #print("symmetry", symmetry, "new index", new_index)
            if new_index not in orbit:
                orbit.append(new_index)
                index_array.remove(new_index)
        orbit_array.append(orbit)
    #print("orbit array", orbit_array)
    #We are ready to calculate structure factor!
    #At first we calculate correlation function for an element of an orbit, then add the correct phase factor
    sym_cor_array=[]
    for orbit in orbit_array:
        cor_expr=basic_expr.replace_indices({1: orbit[0]}) #make operator S_0S_i
        cor_op=ls.Operator(cor_expr,full_basis)
        cor_matrix=cor_op.to_dense() #make numpy matrix
        sym_cor_array.append(thermal_average(cor_matrix,H_matrix,T)) #calculate observable and add to array
    print("sym corrs", sym_cor_array)


    SF_sym=np.zeros((Nq,Nq))
    for i in range(Nq):
        for j in range(Nq):
            SF_sym[i,j]=structure_factor_sym(qxs[i],qys[j],sym_cor_array,coords, orbit_array, L,N_sites)
    #print(SF)
    np.save("sym_cors.npy", SF_sym)

    #Now, let's reverse the order of the symmetry calculations.
    #At first we will make a summation over different translation sectors using the translations and the action of point group.
    #The idea is to construct the observables invariant under the action of the point group so that there is the exact correspondence between different sectors of translation group.
    #The symmetric observables are made from already calculated orbits of C_{0,i}

    hf_bases=[] #array of bases with specific hamming weight
    translation_bases=H_expr.hilbert_space_sectors()
    for basis in translation_bases:
        #print(basis.symmetries, basis.hamming_weight, basis.spin_inversion) #Print all possible symmetries. We have various hamming weights as well
        if basis.hamming_weight==5:
            hf_bases.append(basis)
            print(basis.symmetries, basis.hamming_weight, basis.spin_inversion) #Print all possible symmetries. We have various hamming weights as well
    translation_group=H_expr.abelian_permutation_group()

    symmetric_exprs=[]
    for orbit in orbit_array:
        if len(orbit)>1:
            print("orbit", orbit, "basic_expr", basic_expr)
            point_expr=ls.Expr("0.0 Sx0 Sx1")
            for j in orbit:
                point_expr+=basic_expr.replace_indices({1: j})#make operator S_0S_i
            print("point_expr", point_expr)
            cor_expr=point_expr
            for translation in translation_group:
                print(T)
                cor_expr+=point_expr.replace_indices({n: n^translation for n in range(9)})
            print(cor_expr)
            symmetric_exprs.append(cor_expr)
    print("sym exprs", symmetric_exprs)

    #Now, let's make a check, which representations will give the same answer. Let's at first focus on a specifiv value of hamming weight.
    for basis in hf_bases:
        print(basis.symmetries)
        basis.build()
        cor_op_sym=ls.Operator(symmetric_exprs[0],basis)
        cor_matrix_sym=cor_op.to_dense() #make numpy matrix
        H_op_sym=ls.Operator(H_expr,basis)
        H_matrix_sym=H_op_sym.to_dense()
        print(cor_matrix_sym)
        print(H_matrix_sym)
        corr=thermal_average(cor_matrix_sym,H_matrix_sym,T) #calculate observable
        print("corr", corr)


    


main()
